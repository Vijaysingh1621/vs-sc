import * as fs from 'fs';
import * as path from 'path';
import * as vscode from 'vscode';
import { OwaspDetector } from './detectors/owaspDetector';
import { SansDetector } from './detectors/sansDetector';
import { LanguageDetector } from './detectors/languageDetector';
import { VulnerabilityFixer } from './fixers/vulnerabilityFixer';

export interface Vulnerability {
    id: string;
    type: string;
    category: 'OWASP' | 'SANS';
    severity: 'low' | 'medium' | 'high' | 'critical';
    title: string;
    description: string;
    file: string;
    line: number;
    column: number;
    length: number;
    code: string;
    cwe?: string;
    recommendation: string;
    fixable: boolean;
}

export interface ScanResult {
    file: string;
    language: string;
    vulnerabilities: Vulnerability[];
    scanTime: number;
}

export class VulnerabilityScanner {
    private owaspDetector: OwaspDetector;
    private sansDetector: SansDetector;
    private languageDetector: LanguageDetector;
    private fixer: VulnerabilityFixer;

    constructor() {
        this.owaspDetector = new OwaspDetector();
        this.sansDetector = new SansDetector();
        this.languageDetector = new LanguageDetector();
        this.fixer = new VulnerabilityFixer();
    }

    async scanWorkspace(workspacePath: string, token?: vscode.CancellationToken): Promise<ScanResult[]> {
        const results: ScanResult[] = [];
        const files = await this.getFilesToScan(workspacePath);

        for (let i = 0; i < files.length; i++) {
            if (token?.isCancellationRequested) {
                break;
            }

            const file = files[i];
            try {
                const content = fs.readFileSync(file, 'utf8');
                const result = await this.scanFile(file, content);
                if (result.vulnerabilities.length > 0) {
                    results.push(result);
                }
            } catch (error) {
                console.error(`Failed to scan ${file}:`, error);
            }
        }

        return results;
    }

    async scanFile(filePath: string, content: string): Promise<ScanResult> {
        const startTime = Date.now();
        const language = this.languageDetector.detectLanguage(filePath, content);
        
        const vulnerabilities: Vulnerability[] = [];

        // Scan for OWASP Top 10 vulnerabilities
        const owaspVulns = await this.owaspDetector.detect(filePath, content, language);
        vulnerabilities.push(...owaspVulns);

        // Scan for SANS Top 25 vulnerabilities
        const sansVulns = await this.sansDetector.detect(filePath, content, language);
        vulnerabilities.push(...sansVulns);

        // Remove duplicates and sort by severity
        const uniqueVulns = this.deduplicateVulnerabilities(vulnerabilities);
        const sortedVulns = this.sortBySeverity(uniqueVulns);

        return {
            file: filePath,
            language,
            vulnerabilities: sortedVulns,
            scanTime: Date.now() - startTime
        };
    }

    async generateFix(vulnerability: Vulnerability): Promise<{ replacement: string; description: string } | null> {
        return this.fixer.generateFix(vulnerability);
    }

    private async getFilesToScan(workspacePath: string): Promise<string[]> {
        const files: string[] = [];
        const supportedExtensions = [
            '.js', '.ts', '.jsx', '.tsx', '.vue', '.svelte',
            '.py', '.java', '.c', '.cpp', '.cs', '.php',
            '.rb', '.go', '.rs', '.kt', '.swift', '.scala',
            '.sql', '.yaml', '.yml', '.json', '.xml',
            '.html', '.htm', '.css', '.scss', '.sass'
        ];

        const scanDirectory = (dir: string) => {
            const entries = fs.readdirSync(dir, { withFileTypes: true });
            
            for (const entry of entries) {
                const fullPath = path.join(dir, entry.name);
                
                if (entry.isDirectory()) {
                    // Skip common directories that don't need scanning
                    if (!['node_modules', '.git', 'dist', 'build', '.next', 'coverage'].includes(entry.name)) {
                        scanDirectory(fullPath);
                    }
                } else if (entry.isFile()) {
                    const ext = path.extname(entry.name).toLowerCase();
                    if (supportedExtensions.includes(ext)) {
                        files.push(fullPath);
                    }
                }
            }
        };

        scanDirectory(workspacePath);
        return files;
    }

    private deduplicateVulnerabilities(vulnerabilities: Vulnerability[]): Vulnerability[] {
        const seen = new Set<string>();
        return vulnerabilities.filter(vuln => {
            const key = `${vuln.file}:${vuln.line}:${vuln.column}:${vuln.type}`;
            if (seen.has(key)) {
                return false;
            }
            seen.add(key);
            return true;
        });
    }

    private sortBySeverity(vulnerabilities: Vulnerability[]): Vulnerability[] {
        const severityOrder = { 'critical': 0, 'high': 1, 'medium': 2, 'low': 3 };
        return vulnerabilities.sort((a, b) => 
            severityOrder[a.severity] - severityOrder[b.severity]
        );
    }
}